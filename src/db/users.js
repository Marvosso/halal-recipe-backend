/**
 * Users Data Access Layer
 * Handles all database operations for users table
 */

import { getPool } from "../database.js";
import bcrypt from "bcrypt";

/**
 * Create a new user
 * @param {string} email - User email
 * @param {string} password - Plain text password (will be hashed)
 * @returns {Promise<Object>} Created user object (without password_hash)
 */
export async function createUser(email, password) {
  if (!email || !password) {
    throw new Error("Email and password are required");
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new Error("Invalid email format");
  }

  // Validate password length
  if (password.length < 6) {
    throw new Error("Password must be at least 6 characters");
  }

  const pool = getPool();
  const client = await pool.connect();

  try {
    // Hash password
    const passwordHash = await bcrypt.hash(password, 10);

    // Insert user (with UUID generated by database)
    const result = await client.query(
      `INSERT INTO users (email, password_hash, display_name)
       VALUES ($1, $2, $3)
       RETURNING id, email, display_name, profile_image_url, created_at`,
      [email.toLowerCase().trim(), passwordHash, email.split("@")[0]]
    );

    return result.rows[0];
  } catch (error) {
    // Handle duplicate email
    if (error.code === "23505") {
      // PostgreSQL unique violation
      throw new Error("Email already exists");
    }
    throw error;
  } finally {
    client.release();
  }
}

/**
 * Get user by email
 * @param {string} email - User email
 * @returns {Promise<Object|null>} User object with password_hash, or null if not found
 */
export async function getUserByEmail(email) {
  if (!email) {
    return null;
  }

  const pool = getPool();
  const client = await pool.connect();

  try {
    const result = await client.query(
      `SELECT id, email, password_hash, display_name, profile_image_url, created_at
       FROM users
       WHERE email = $1`,
      [email.toLowerCase().trim()]
    );

    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

/**
 * Get user by ID
 * @param {string|number} userId - User ID (UUID or number)
 * @returns {Promise<Object|null>} User object (without password_hash), or null if not found
 */
export async function getUserById(userId) {
  if (!userId) {
    return null;
  }

  const pool = getPool();
  const client = await pool.connect();

  try {
    const result = await client.query(
      `SELECT id, email, display_name, profile_image_url, created_at
       FROM users
       WHERE id = $1`,
      [userId]
    );

    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

/**
 * Verify user password
 * @param {string} email - User email
 * @param {string} password - Plain text password
 * @returns {Promise<Object|null>} User object (without password_hash) if password matches, null otherwise
 */
export async function verifyUserPassword(email, password) {
  const user = await getUserByEmail(email);
  if (!user) {
    return null;
  }

  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) {
    return null;
  }

  // Return user without password_hash
  const { password_hash, ...userWithoutPassword } = user;
  return userWithoutPassword;
}

/**
 * Get all users (for dev/testing)
 * @returns {Promise<Array>} Array of user objects (without password_hash)
 */
export async function getAllUsers() {
  const pool = getPool();
  const client = await pool.connect();

  try {
    const result = await client.query(
      `SELECT id, email, created_at
       FROM users
       ORDER BY created_at DESC`
    );

    return result.rows;
  } finally {
    client.release();
  }
}

/**
 * Update user display name
 * @param {string|number} userId - User ID (UUID or number)
 * @param {string} displayName - New display name
 * @returns {Promise<Object|null>} Updated user object (without password_hash), or null if not found
 */
export async function updateUserDisplayName(userId, displayName) {
  if (!userId || !displayName) {
    throw new Error("User ID and display name are required");
  }

  const pool = getPool();
  const client = await pool.connect();

  try {
    const result = await client.query(
      `UPDATE users 
       SET display_name = $1 
       WHERE id = $2
       RETURNING id, email, display_name, profile_image_url, created_at`,
      [displayName.trim(), userId]
    );

    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

/**
 * Update user profile image URL
 * @param {string|number} userId - User ID (UUID or number)
 * @param {string} profileImageUrl - New profile image URL
 * @returns {Promise<Object|null>} Updated user object (without password_hash), or null if not found
 */
export async function updateUserProfileImage(userId, profileImageUrl) {
  if (!userId) {
    throw new Error("User ID is required");
  }

  const pool = getPool();
  const client = await pool.connect();

  try {
    const result = await client.query(
      `UPDATE users 
       SET profile_image_url = $1 
       WHERE id = $2
       RETURNING id, email, display_name, profile_image_url, created_at`,
      [profileImageUrl, userId]
    );

    return result.rows[0] || null;
  } finally {
    client.release();
  }
}
